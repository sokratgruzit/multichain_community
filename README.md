<details><summary>Announcement Email:</summary>
<p>

### Calling all blockchain enthusiasts!

CORE Multichain is building the future through blockchain technology and is looking to expand its team. We are looking for AI researchers, university professors, computer scientists, mathematicians, cryptographers, and data scientists to join our team.

We also offer a grant program for projects that will add value to the CORE Multichain ecosystem. Grants are available for the following project categories:
- Tools for development and deployment (e.g., IDEs and SDKs for side chains)
- Runtime Modules related to interoperability, governance, and consensus
- Ecosystem developers like wallets and exchanges.
- Monitoring, such as block explorers and off-chain data services
- Distributed file system developers
- Bridge integrators

Since CORE is centered around its community, we want the developer, science, and academic communities to join our efforts to help us enhance our ecosystem. Therefore, we encourage project proposals. These proposals can be related to any-blockchain related topics such as blockchain consensus protocols, smart contracts, sharding, etc. We are also interested in other fields such as AI, machine learning, game theory, cloud computing, and 5G.

If you are interested in joining the CORE Multichain team or have a project that you believe can add value to CORE Multichain and blockchain technology as a whole, then feel free to contact us.

:+1: We look forward to hearing from you! :smiling_face_with_three_hearts:

</p>
</details>
<details><summary>Announcement:</summary>
<p>

#### CORE Multichain is a blockchain movement that aims to solve scalability, interoperability, and throughput problems while increasing user privacy and usability.

We strive to make significant contributions towards Web3 technology by promoting innovation in the blockchain and digital currency space. In our efforts to maximize innovation in the blockchain technology and Web3 space, we are excited to announce that CORE Multichain will be hosting a hackathon! Developers from across the globe will be able to participate in this hackathon to create the next best innovation in blockchain technology.

Since blockchain technology is in its infancy, there is a lot of room for innovation. However, we are looking for developers that can innovate in the following aspects of blockchain and cryptocurrency technology:

* Consensus Protocols
* Smart Contracts
* Sharding
* Scalability
* Security and Privacy
* Data Analytics
* Artificial Intelligence
* Machine Learning
* Game Theory
* Cloud Computing
* Edge Computing
* 5G and Beyond

> Developers can either choose one of the aspects or touch on multiple aspects in their solution. 
</p>
</details>

### Guidelines:

:point_right: CORE Multichain lives by the belief that together, members and teams of the blockchain industry can grow in a collective effort to make significant contributions to the blockchain space. We support many teams and organizations within the blockchain community and receive requests to partner and/or sponsor many projects. Unfortunately, with the high volume of requests that we receive, we cannot participate and answer every request. :point_left:

:sparkles: To nurture and grow our blockchain community, we host annual events such as hackathons and offer a grant program to help exciting blockchain-related project proposals go from idea to reality. :sparkles:

:boom: Teams need to register and submit their project proposals to participate in our hackathon. We only allow project proposals that deal with the blockchain-related aspects listed in our hackathon announcement. Once approved, teams will be notified of the following steps by a member of the CORE Multichain team. :boom:

:star2: As mentioned, teams can also apply for grants. Teams need to send grant proposals to the CORE Multichain team like the hackathon application process. Only projects under the blockchain topics listed in our hackathon announcement will be considered. The grant process is also milestone-based. This ensures that projects who send these requests are serious about the process and about contributing to the blockchain space. :star2:

#### We recommend the following guidelines when writing a proposal for a grant or a project for the hackathon:

- List which blockchain-related aspect your hackathon project or grant project will fall under.
    For more information, you can refer to the hackathon announcement to see which blockchain-related aspects are supported by the CORE Multichain team. Your project can fall under more than one of the supported blockchain aspects.

- Focus your proposal around what problem in the blockchain space your project addresses.

- Discuss how your project can contribute to the CORE Multichain ecosystem.

- Introduce your team.

### Code of Conduct:

> This event is a community hackathon to promote collaboration, innovation, and learning in the CORE Multichain and broader blockchain communities. We encourage and value the participation of each member of the community and want each member and team that participates in our hackathon to have an enjoyable experience. Therefore, all participants are expected to show respect and courtesy towards all other participants in the hackathon. All participants are required to conform to the following Code of Conduct which organizers will enforce throughout the event.

#### The Code

> The Code intends to prohibit activities including but not limited to:

- Offensive comments towards others
- Any activity that can be seen as, or regarded as, harassing, demeaning, mocking, or       intimidating others, especially this behavior as it relates to characteristics such as:

    * Gender
    * Sexual orientation
    * Physical or mental ability
    * Age
    * Socioeconomic status
    * Ethnicity
    * Physical appearance
    * Race
    * Religion

- Other prohibited behaviors include, but are not limited to:

    * Stalking
    * Unwanted sexual attention
    * Use of sexualized content

:boom: Should any participant take part in any behavior deemed as harassment, they will be asked to stop the behavior. Failure to comply with the request to stop the behavior immediately will result in the participant's dismissal from the event. :boom:

:sparkles: Sponsors, mentors, volunteers, judges, organizers, CORE Multichain staff, and anyone else at the event are also subject to the anti-harassment policy. Attendees should not use sexualized content in their projects or during the event. :sparkles:

:star: Should a participant engage in behavior that violates this code of conduct, the hackathon organizers will take any action they deem appropriate and necessary, including warning the offender or expelling them from the event. :star:

:sparkles: If you are in a situation wherein you are uncomfortable or think there may be a potential violation of the code of conduct, please report it immediately to one of the event organizers or email the CORE Multichain team. All reports will remain anonymous. :sparkles:

### Event Rules & Conditions

1. The following rules & conditions apply to this CORE Multichain hackathon ("The Event"). :point_left:

2. You are fully responsible for any damage or injury caused by you in your participation in The Event (whether the damage is to persons or property, and whether to yourself or others) and release CORE Multichain, The Event, all sponsors of The Event, The Event volunteers, The Event staff, guests of The Event and all other participants in The Event (collectively, the "Releasees") from any liability therefore. **YOU ARE AWARE THAT YOUR PARTICIPATION IN The Event IS SOLELY AT YOUR OWN RISK, AND THAT THE RELEASE HEREIN IS INTENDED TO REFLECT THAT UNDERSTANDING**. :point_left:

3. Ownership of any developments made by you during The Event, and all right, titles, and interest in those developments, including the intellectual property right therein, shall be yours. However, you acknowledge that during the course of the event, you may have access to products, developments, information, and other materials belonging to other participants of The Event and/or other third parties ("Third Party Materials") and that nothing in this Agreement will be deemed as a transfer of any ownership, right, title or interest in such Third Party Materials to you. Your only rights to the Third Party Materials shall be those expressly granted to you by the owner(s) of the Third Party Materials. Any APIs or other software provided to you by the sponsors of The Event are subject to the subscription terms and software licenses associated with such APIs or other software.  :point_left:

4. You acknowledge that The Event is intended to be an event where ideas are shared freely. Therefore, recognize that any sharing of information with participants of The Event, The Event sponsors, and/or other third parties during The Event is solely at your own discretion and risk. Should you wish to protect your information, it is solely your responsibility to implement the necessary confidentiality and security measures concerning the persons to whom you disclose your information. None of the Releasees shall have any obligation under this Agreement or by virtue of their participation in The Event concerning your information.  :point_left:

5. The Organizers have the unrestricted right to use your likeness, image, voice, opinions, and appearance, and also any images of your projects, developments, materials, and belongings made at or brought to The Event, captured through video, photographs, or other media during The Event for the express purpose of creating promotional material (the "Images"), which will be used in websites, promotional materials, publications and other media of any of the Organizers, whether in print or electronically (the "Materials"). The aforementioned right includes permission to copyright, use, re-use, publish, and republish images in which you may be included, intact or in part, composite or distorted in character or form, without restriction as to changes or transformations, in conjunction with your own or fictitious name, reproductions in color or otherwise, made through any and all media now or hereafter known; :point_left:

    1. The Organizers shall solely own the Materials in which you or your Images, in whole or in part, may appear, including copyright interests, and you have no ownership rights therein; :collision:

    2. You give all clearances, copyright and otherwise, for the use of your Images and waive any moral rights that you may have in the Materials in which you or your Images may appear. The rights granted to the Hackathon Organizers herein are permanent and global, and your Images may continue to be used after the completion of The Event; :collision:

    3. You relinquish any right that you may have to examine or approve the Materials in which you or your Images may appear or the use to which they may be applied; :collision:

6. You agree that the Organizers may share your registration details, LinkedIn/Github profiles, details of your Hackathon product, and other information obtained from you in the course of, or relating to, The Event with the sponsors of The Event, and acknowledge that such sponsors of The Event may contact you during and after The Event. By agreeing to this document and/or participating in The Event, you are providing your express consent to communications by the Organizers and sponsors (including email communications, both marketing and informational) respecting the products and services of the Organizers, sponsors, and future events. :point_left:

7. For valuable consideration, including permission to take part in The Event, the undersigned on behalf of him/herself, his or her personal representatives, assignees, heirs and next of kin: hereby covenants not to sue, and releases, waives, and discharges the Releasees, their owners, officers, agents, affiliates, employees, volunteers, and/or any other person or entity in any way associated with The Event, from liability for any injury to the person or property or death of the undersigned arising out of or related to use of the premises, equipment, or other facilities of the Releasees, whether caused by an act of negligence of the Releasees or otherwise; and hereby assumes full responsibility for any risk of bodily injury, death or property damage arising out of or related to their participation in The Event, whether occurring to the undersigned or to any other person or entity for whom the undersigned is responsible or with whom the undersigned is associated, and whether caused by an act of negligence of the Releasees or otherwise. The foregoing release includes, but is not limited to, any occurrences of personal injury, illness (food-borne or otherwise), and loss of belongings, whether by theft or otherwise. The undersigned further agrees that this instrument (the terms of which collectively are referred to as the Agreement) is intended to be as broad and inclusive as is permitted by the laws of the State of California and that if any portion thereof is held invalid, that portion shall be invalid only to the extent required by law. The balance shall notwithstanding, continue in full force and effect. :point_left:

8. If selected as a winner of a CORE Multichain award, your acceptance of the CORE Multichain award means you agree to the following: :point_down:

    1. You will not belittle CORE Multichain or its products, services, agents, representatives, directors, officers, shareholders, attorneys, vendors, employees, affiliates, business partners, assigns, or successors, or any other person acting by, through, under or in concert with any of them, with any written or oral statement. Nothing in this paragraph shall prohibit the winner from providing truthful information in response to a valid subpoena or any other legal process; however, the winning participant agrees to provide the Company sufficient notice of such to allow the Company the opportunity to oppose such subpoena or legal process before providing any information (unless expressly prohibited by applicable law).:point_left:

    2. Any media created about winning the event will first be shared with the CORE Multichain team beforehand to coordinate and help you maximize the reach of your media. :point_left:

    3. You agree to an interview with a writer affiliated with the team, which will feature your project on the CORE Multichain website and share your project with the greater community. :point_left:

:sunny: our project is to be created during the duration of the hackathon. If your project is an improvement on an existing project, you will need to specify where your project started, and the base project ended. Projects that were submitted to a previous hackathon will not be permitted. :sunny:

> Coding Conventions - Document conventions
# Document Conventions

## Rebuilding the content table

Performing the following actions will require that the main content table be updated: :point_down:

- Adding a file 
- Moving a file
- Deleting a file
- Updating a file's main header

To update the content table:

* You would first need to install the dependencies by running the following command: :point_down:

    ``` yarn ``` :zap:


* To rebuild, run the following: :point_down:

    ``` yarn generate-toc ``` :zap:

## Adding a document

>The below structure should be followed when adding a document file for this repo:

```

** [<](README.md) &nbsp; ${main_header} ** 
${table_of_content}
&nbsp;
${content}
[Back to the top](#--${main_header_dashed})

```
* main_header - The main title for the page. For example, for this page, it's "Developer Documentation Guidelines."

* main_header_dashed - the same as the "main_header," only all lower caps separated by dashed instead of spaces.
For example, for this page, it's: "developer-documentation-guidelines."

* table_of_content (Optional) - If needed (the page is long), then add a table of contents for this page.

* content - The actual content of the page should only use "native" markdown syntax, without any html tags.

:arrow_up: [Back to the top](#document-conventions) :arrow_up:

Coding Conventions - Javascript Code Conventions
# JavaScript Code Conventions

* [File Names](#File-Names)
* [Comments](#Comments)
* [Exports](#Exports)

## File Names
* Postfix the names of index files with the name of their parent directory

```ruby 

//incorrect
src/
   
components/
        
MyComponent/
              
index.js // <--
              
MyComponent.js
              
styles.js
//correct
src/
  
components/
       
MyComponent/
             
indexMyComponent.js // <--
             
MyComponent.js
             
styles.js

```
:arrow_up: [Back to the top](#Javascript-Code-Conventions) :arrow_up:

## Comments
* Use ```TODO + initials``` comments to label any non-production-ready code

```
//incorrect
const denomination = {
 currencyCode: 'USD'  //This definitely needs to be changed!
}

//correct
const denomination = {
 currencyCode: 'USD' // Todo: Replace hard coded currencies with library -paulvp
}

```

* Break more than double nested array dereferences into multiple lines

```
// incorrect

// correct

```

* Break more than double nested or function calls into multiple lines

```
// incorrect

//correct

```

[Back to the top](#Javascript-Code-Conventions)

## Exports
* Only used named exports

```
// incorrect
export default class FullWalletListRow extends Component<OwnProps> {
// correct
export class FullWalletListRow extends Component<OwnProps> {

```

[Back to the top](#Javascript-Code-Conventions)


File Names
* Postfix the names of index files with the name of their parent directory

//incorrect
src/
  
components/
      
MyComponent/
            index.js // <--
           
MyComponent.js
           
styles.js
//correct
src/
  
components/
      
MyComponent/
            
indexMyComponent.js // <--
            
MyComponent.js
            
styles.js

Back to the top

Comments
* Use TODO + initials comments to label any non-production-ready code

//incorrect
const denomination = {
   
currencyCode: 'USD'//This definitely needs to be changed!
}

//correct
const denomination = {
   
currencyCode: 'USD' // Todo: Replace hard coded currencies with library -paulvp
}

* Break more than double nested array dereferences into multiple lines

// incorrect

// correct

* Break more than double nested or function calls into multiple lines

// incorrect

//correct

Back to the top

Exports

* Only use named exports

// incorrect
export default class FullWalletListRow extends Component<OwnProps> {
// correct
export class FullWalletListRow extends Component<OwnProps> {

Back to the top

Javascript Project Setup Conventions
# JavaScript Project Setup Conventions

* [Package Management](#Package-Management)
 - [Yarn](#Yarn)
 - [Security Configuration](#Security-Configuration)
* [Testing](#Testing)
 - [Jest](#Jest)
* [Type Checking](#Type-Checking)
 - [Flow](#Flow)
* [Commit Hooks](#Commit-Hooks)
 - [Husky](#Husky)
* [Formatting](#Formatting)
* [Dependencies](#Dependencies)
 - [Do](#Do)
 - [Don't](#Don't)
* [Scripts](#Scripts)

This document aims to outline the code conventions used by all CORE Multichain projects. It lists the recommendations for utilities, formatting, scripts, etc.

## Package Management

#### Yarn
We manage our package dependencies with Yarn v1. All repositories should commit a .yarnrc file with at least the following:

```
--ignore-scripts true
```

This will prevent scripts from running during package installation. We do not allow scripts to run after package installation due to security reasons. All build scripts should run with ``` yarn prepare ```, separate from ``` yarn ```.

#### 
Security Configuration

Every developer must run "`yarn config set ignore-scripts true ``` on their local development environment. This prevents scripts from running during package installation for any project missing a properly configured ``` .yarnrc ``` (whether CORE Multichain's repo or a 3rd-party's). A shell alias that combines ``` yarn install ``` and ``` yarn prepare ``` may be added to a developers' shell config for convenience. For example, add to your ``` .zshrc ``` or ``` .bashrc ```:

```
alias yip='yarn && yarn prepare'
```

## Testing

#### Jest

** Usage **

```
// package.json
"test": "jest"
```

[Back to the top](#JavaScript-Project-Setup-Conventions)

## Type Checking

#### Flow

** Usage **

```
// package.json
"flow": "flow"
```

[Back to the top](#JavaScript-Project-Setup-Conventions)

## Commit Hooks

#### Husky

Installing

```
yarn add -D husky
```

** Usage **

```
//package.json
"pre-push": "yarn test"
```

[Back to the top](#JavaScript-Project-Setup-Conventions)

Formatting

* eslint-config-standard-kit - github

* Eslint - github

* Prettier - github

* Lint-staged - github

* Import-sort - github

* Sort-package-json - github
- installing

```
yarn add sort-package-json import-sort-cli import-sort-style-module prettier-eslint-cli lint-staged
```

** Usage **

```
// package.json
"scripts": {
 
"format": "sort-package-json; import-sort -l --write '*.js' 'src/**/*.js'; prettier-eslint --write '*.js' 'src/**/*.js'",
 
"precommit": "lint-staged"
},
"prettier": {
 
"printWidth": 120
},
"lint-staged": {
 
"*.js": ["yarn format", "git add"]
},
"importSort": {
 
".js, .es": {
   
"parser": "babylon",
   
"style": "module"
  }
}
```

[Back to the top](#JavaScript-Project-Setup-Conventions)

## Dependencies

All dependencies should be defined with their full URLs or NPM package version. GitHub short-hand URLs should not be used due to an outstanding issue with Yarn not running prepare/prepack for these types of dependencies.

## Do

```
{
 
"dependencies": {
    "react": "^17.0.1",
   
"edge-currency-accountbased": "git://github.com/EdgeApp/edge-currency-accountbased.git#v0.7.33"
  }
}
```

## Don't

```
{
 
"dependencies": {
   
"edge-currency-accountbased": "EdgeApp/edge-currency-accountbased#v0.7.33"
  }
}
```

[Back to the top](#JavaScript-Project-Setup-Conventions)

## Scripts

Each repo should have the following package.json scripts:

* ``` build ```: If necessary, run rollup, webpack, and flow-copy to populate ``` lib ``` folder. Should not run any lint, flow checking, or tests
* ``` flow ```: Run ``` flow ```
* ``` lint ```: Run ``` standard.js ``` or equivalent and ``` flow ```
* ``` test ```: Run ``` lint ``` and ``` flow ```. Flow should exclude ``` *.js.flow ``` files. Lastly run ``` mocha ``` or ``` jest ``` tests
* ``` precommit ```: Run ``` build ``` then ``` test ```
* ``` prepare ```: Run ``` build ```

[Back to the top](#JavaScript-Project-Setup-Conventions)

Server Conventions
# Server Conventions
* [Server Versions](#Server-Conventions)
* [Client Libraries](#Client-Libraries)
* [Server Exported Types](#Server-Exported-Types)
* [Client Usage of Server Exported Types](#Client-Usage-of-Server-Exported-Types)

CORE Multichain uses a micro-services architecture with small code bases, each dedicated to a specific purpose. Each server is located in its own git repository with a name like "core-purpose-server." Each server should have ``` "private": true ``` in its ``` package.json ``` file since the server code does not belong on NPM.

## Server Versions

Even though the server does not live on NPM, we still maintain a ``` CHANGELOG.md ``` file and a ``` package.json ``` version number for documentation purposes. "major.minor" format is used for the version number, with no patch number. Since the deployment pipeline is responsible for automatically appending a patch version each time, it creates and deploys a build. Therefore these patch numbers are not present in the git codebase (similar to the app's build number).

* Minor version bumps indicate new features, such as new endpoints.
* Major version bumps indicated deactivated endpoints.

If a change cannot be backward-compatible, then it should exist as a new endpoint. This is to ensure that the server does not implement any breaking changes. Older endpoints should be deprecated and deactivated after some period of time. These deactivated endpoints should not be deleted but rather return HTTP status code 410, "Gone," or some other similar error.

[Back to the top](#Server-Conventions)

# Client Libraries
Each CORE Multichain server should include a matching client library, typically named "core-purpose-client." This library should contain and implement all of the logic needed to communicate with the server, including knowledge of the server's endpoints, query parameters, required HTTP headers, request and reply formats, and any algorithms needed to use the server's data.

For example, the client library "core-sync-client" would include the logic needed to maintain a disk repository and identify out-of-date files and synchronize changes with the server. The client library "core-info-client" might be used to fetch lists of resources from the info server, as well as logic for performing client-side load balancing using these resource lists.

Since these client libraries can implement bug fixes and add features without requiring server changes (and vice versa), they are versioned independently from the server they communicate with using Semantic Versioning.

Servers are encouraged to share code with their client libraries, such as type definitions, cleaners, constant definitions, and so forth. Putting the shared code in the client library is the most convenient option since the client would be published to NPM for easy consumption by the server. However, it is also possible to share code the other way around (from the server, as below).

[Back to the top](#Server-Conventions)

# Server Exported Types

Apart from each CORE Multichain server providing its own library, it is also possible to expose a collection of cleaner functions from the server repository itself. Since server code should not be published to NPM, clients that want to make use of this information should import the server via git URL, like ``` "core-info-server": ``` ``` "git://github.com/CoreApp/core-info-server.git#v1.0" ```

Inside the server repository, the ``` package.json ``` fields ``` main ``` and ``` types ``` should point to the exported cleaners, as can be seen here in the following snippet:

```
// types.ts
import { asArray, asNumber, asObject, asString } from 'cleaners'

// Example of an API request body
export type ApiGetRequest = ReturnType<typeof asApiGetRequest>
export const asApiGetRequest = asObject({
 
currencyCode: asString
})

// Example of an API response object
export type ApiGetResponse = ReturnType<typeof asApiGetResponse>
export const asApiGetResponse = asObject({
 
transactions: asArray(asObject({
   
txid: asString,
   
amount: asString,
   
//...
  }))
})

// ...

```

You can export the TypeScript types and cleaners from the server by including the following declarations in the package.json manifest file:

```
{
 
"name": "my-server",
 
"version": "1.0.1",
  ...
 
"main": "lib/types.js",
 
"types": "lib/types.d.ts",
  "files": [
   
"lib/*"
  ],
 
"scripts": {
    ...
   
"build.lib": "sucrase -q -t typescript,imports,jsx -d ./lib ./src",
   
"build.types": "tsc && cpr lib/src lib/ && rimraf lib/src",
   
"clean": "rimraf lib",
   
"prepare": "npm-run-all clean -p build.*",
    ...
  },
  ...
 
"dependencies": {
    ...
   
"cleaners": "^0.3.2",
    ...
  },
 
"devDependencies": {
    ...
   
"cpr": "^3.0.1",
   
"npm-run-all": "^4.1.5",
   
"sucrase": "^3.12.1",
   
"typescript": "^4.1.3"
    ...
  }
}

```

Following is a descriptive breakdown of each dependency and configuration:

* ``` "main" ``` and ``` "types" ``` are set to the location for the exported types build output (cleaners from the .js file and type declarations from the .d.ts file)
* ``` "files" ``` is set to include all files in the ``` lib/ ``` directory. This enables the creation of tarball artifacts using ``` npm pack ``` or ``` yarn pack ``` if ever necessary.
* Our scripts include:
- ``` "prepare" ``` this is our main build script which cleans the build output directory ("`lib/` ") first and then runs all our separate build steps in parallel.
- ``` "build.lib" ``` this will build the JS files to ``` lib/ ``` from the TS 
files in ``` src/ ``` using ``` sucrase ``` and our typescript configuration (``` tsconfig.json ```).
- ``` "build.types" ``` will build the type declaration files ("`d.ts` "files) to "`lib/src` "from the TS files in "`src/` "and then move those files to "`lib/` ".
- ``` "clean" ``` is our cleanup script and removes the "`lib/` "build directory.
* The following are necessary dependencies for the setup:
- ``` cleaners ```: Used for runtime type definitions for runtime type validation.
- ``` cpr ```: needed if you want to move directories in our build scripts.
- ``` npm-run-all ```: Necessary to run our scripts in parallel.
- ``` sucrase ```: Necessary to run and build typescript (as an alternative to using tsc for JS output).
- ``` typescript ```: Necessary for building type definition files and for development.

[Back to the top](#Server-Conventions)

## ClientUsage of Server Exported Types
A client can use the exported types from a server by including them as a dependency using the GitHub repo URL in its ``` package.json ``` file:

```
{
  ...
 
"dependencies": {
    "my-server": "git://github.com/EdgeApp/my-server.git#v1.0"
  }
  ...
}

```

Take note of the git tag ``` v1.0 ``` that is included in the URL to point to a specific server version for the dependency.  

The client is then able to import the types:

```
import { asApiGetRequest, asApiGetResponse } from 'my-server'

// ... Use cleaners to sanitize and validate IO to the server

```

There are no guarantees that types won't have breaking changes from one server version to another since server versions track the API changes of the HTTP interface and not the versioning of any exported types. This is one of the caveats to exporting types from the server and why it is recommended to define and export types on a complementary client-side library for the server.

[Back to the top](#Server-Conventions)


Git/Commit rules
# Commit rules

* [Subject Line](#Subject-Line)
 - [Use the imperative mood in the subject line](#Use-the-imperative-mood-in-the-subject-line)
 - [Limit the subject line to 50 characters](#Limit-the-subject-line-to-50-characters)
 - [Capitalize the subject line](#Capitalize-the-subject-line)
 - [Do not end the subject line with a period](#Do-not-end-the-subject-line-with-a-period)

* [Body](#Body)
 - [Use the body to explain what and why vs. how](#Use-the-body-to-explain-what-and-why-vs.-how)
 - [Separate body from subject with a blank line](#Separate-body-from-subject-with-a-blank-line)
 - [Wrap the body at 72 characters](#Wrap-the-body-at-72-characters)

* [Standards](#Standards)
 - [Clean commit principles](#Clean-commit-principles)
 - [Rebasing](#Rebasing)

# Subject Line

## Use the imperative mood in the subject line

```

# incorrect
git commit -m "Fixed bug with Y"
git commit -m "Changing behavior of X"
git commit -m "More fixes for broken stuff"
git commit -m "Sweet new API methods"

```

```

# correct
git commit -m "Refactor subsystem X for readability"
git commit -m "Update getting started documentation"
git commit -m "Remove deprecated methods"
git commit -m "Release version 1.0.0"

```

## Limit the subject line to 50 characters

```
# incorrect (> 50 chars)
git commit -m "Add NEW_WALLET action to global action file and add NEW_WALLET action creator"

```

```

# correct
git commit -m "Add NEW_WALLET action and action creator"

```

## Capitalize the first letter of the first word in the subject line

```

# incorrect
git commit -m "accelerate to 88 miles per hour"

```

```

# correct
git commit -m "Accelerate to 88 miles per hour"

```

## Do not end the subject line with a period

```

# incorrect
git commit -m "Open the pod bay doors."

```

```

# correct
git commit -m "Open the pod bay doors"

```

[Back to the top](#Commit-rules)

## Body

## Use the body to explain what and why vs. how

```

# incorrect
git commit -m "Decrease time to send transaction

This pull request moves the http request to after signing and sending
transactions.
"

```

```

# correct
git commit -m "Decrease time to send transaction

The core makes an http request before sending each transaction. It
then waits for the return of this request before sending the
transaction. This request took several seconds and is not required 
to complete before sending the transaction.

Moving the request until after the transaction is sent decreases
the time the user spends waiting to send a transaction.
"

```

## Separate body from subject with a blank line

```

# incorrect

git commit -m "Derezz the master control program
MCP turned out to be evil and had become intent on world domination.
This commit throws Tron's disc into MCP (causing its deresolution)
and turns it back into a chess game."

```

```

# correct

git commit -m "Derezz the master control program

MCP turned out to be evil and had become intent on world domination.
This commit throws Tron's disc into MCP (causing its deresolution)
and turns it back into a chess game."

```

## Wrap the body at 72 characters

```

# incorrect (does not wrap at 72 chars)
git commit -m "Simplify serialize. h's exception handling

Remove the 'state' and 'exceptmask' from serialize. h's stream implementations, as well as related methods.

As exceptmask always included 'failbit', and setstate was always called with bits = failbit, all it did was immediately raise an exception. Get rid of those variables, and replace the setstate with direct exception throwing (which also removes some dead code)."

```

```
# correct
git commit -m "Simplify serialize. h's exception handling

Remove the 'state' and 'exceptmask' from serialize. h's stream
implementations, as well as related methods.

As exceptmask always included 'failbit', and setstate was always
called with bits = failbit, all it did was immediately raise an
exception. Get rid of those variables, and replace the setstate
with direct exception throwing (which also removes some dead
code)."

```

Source: [How to write a Git Commit Message](#https://chris.beams.io/posts/git-commit/#seven-rules)

[Back to the top](#Commit-rules)

## Standards
Since open-source work is self-directed, there is no guarantee that others will want your work. With this in mind, you need to work hard to convince maintainers that your work is a good idea.

* Every commit should make obvious improvements to the code.
* Every commit should be independent since maintainers might want some commits and not others.
* No commit should cause breaks in the program. All tests on the commit should pass, and all code should make sense at each point.

If you make a mistake, do not create another commit to fix it! Go back and repair the original commit to make the original commit more desirable.

Your commits should be added in some logical order, for example:

1. Delete code and perform optimizations
2. Add new type definitions and helper components
3. Implement the feature
4. Remove code that was replaced

> Any renaming of variables or files should always be done in their own commits, separate from any code changes.

## Clean Commit Principles

* Avoid doing something only to undo it a few commits later.
* The repo must be free of all mistakes after every commit.
* Each commit should be useful on its own.

## Rebasing

Rebasing is your best friend when preparing work for review. If you need your workflow to be somewhat messy and disorganized to get the job done, then that's fine. However, before you create a pull request for your work to be reviewed, you should interactively rebase ("`git rebase -i'  ") to:

* Splitting: Separating unrelated changes in a commit
* Squashing: Join related commits together
* Reordering: Change the order of commits

Take a look at Git - Rewriting History for a guide on making these edits to your branch. Alternatively, you can refer to the summary below.

#### Splitting commits

Let's say we have 2 commits with 2 unrelated changes. Below are two ways we can fix it.

If it's simple:
1. Stop the rebase right before the commit needs splitting.
2. Re-do and commit the first half of the changes.
3. Continue rebasing.

If it's complex:
1. Use the "e" command to stop at the commit we need to split.
2. Create an "antimatter" commit that un-does half the changes.
3. Revert the "antimatter" commit - this gives a clean commit that makes the changes.
4. Do another rebase to join the original commit & antimatter commits.

#### Joining commits
* Use the "fixup" or "f" command to join two commits and keep the first commit message
* Use the "squash" or "s" command to join commits and edit the commit message
* Use "fixup!" "squash!" in your commit message and add --autosquash to your rebase command to tell git to use these commands in your rebase automatically.

#### Editing commits
* Use the "edit" or "e" command to edit commits. You can make small amendments (git commit -- amend), edit commit messages, etc.
* Before committing changes, make sure to run yar precommit && git rebase -- continue.
* You can even create whole new commits in this mode (omit --amend!

[Back to the top](#Commit-rules)

Git future commit workflow
# Git "Future Commit" Workflow
* [Motivation](#Motivation)
* [Creating a Future Commit](#Creating-a-Future-Commit)
* [Multiple Future Commits](#Mulltiple-Future-Commits)
* [Rewriting History](#Rewriting-History)
 - [Step 1: Create new future commit](#Step-1:-Create-new-future-commit)
 - [Step 2: Moving the dependent feature branch](#Step-2:-Moving-the-dependent-feature-branch)
* [Removing Future Commits](#Removing-Future-Commits)
* [Review Conventions](#Review-Conventions)
* [Git Aliases](#Git-Aliases)
 - [git future [<future-branch>][<feature-branch>]](#git-future-[<future-branch>][<feature-branch>])
 - [git portal <future-branch> [<feature-branch>]](#git-portal-<future-branch>-[<feature-branch>])

## Motivation

We understand that some features in the code might depend on other features on a different branch. That feature's dependency may be in peer review with an outstanding pull request or still a work-in-progress and not yet ready for review. The question is, how can we build on top of that feature's dependency in a clean way that is relatively simple to manage and clear for the reviewer to follow?

The answer to this question is a convention that describes a workflow using "future commits" to organize and identify feature dependencies that have not been merged into the master branch. This is achieved with a single commit for each anticipated feature merge, building a pseudo-master branch to be used until all feature dependencies have been reviewed, approved, and merged.

[Back to the top](#Git-"Future-Commit"-Workflow)

## Creating a Future Commit

Say we have two feature branches, ``` branch-a ``` and ``` branch-b ```. ``` Branch-a ``` is an existing feature branch that has not been merged with master and ``` branch-b ``` is a feature that we wish to build on top of feature branch ``` branch-a ```. To achieve this, we can create a pseudo-merge commit on master and build our ``` feature-b ``` from that commit, like so:

```

git checkout master
git checkout -b feature-b
git merge --no-ff -m"future! feature-a" feature-a
git tag -f future/feature-a

```

The above instructions will first checkout master, then create our second feature branch (``` feature-b "`), merge our dependency feature branch (``` feature-a "`) into our next branch, and then tag the merge commit with a conventional ``` future/feature-a ``` tag for convenient reference to this point in history.

By convention, always use "future!" followed by the branch name as the commit message for the merge commit.

After executing the above commands, we are now ready to commit to ``` branch-b ```. When we submit our PR, the reviewer can see our future commit and know that all the work before this future commit is to be reviewed separately within another PR.

[Back to the top](#Git-"Future-Commit"-Workflow)

## Multiple Future Commits

Should we be in the situation where we have a third feature that depends on ``` branch-b ```, we can create a future commit for this using the same commands:

```

git checkout master
git checkout -b feature-c
git merge --no-ff -m"future! feature-b" feature-b
git tag -f future/feature-b

```

In the above instructions, we created our new feature, ``` feature-c ```, and merged ``` feature-b ```. Finally, we tagged this new merge commit with ``` future/feature-b ```.

When submitting our PR for ``` feature-c ```, the reviewer can see two future commits and know only the commits following the last future commit.

[Back to the top](#Git-"Future-Commit"-Workflow)

## Rewriting History

Sometimes, a feature might receive requested changes from a reviewer. When this happens on a feature that is a dependency for other features, we'll want to rebase our *dependent* features onto the modified branch of the *dependency* feature.

If a dependency branch changes, we can leverage the ``` future/<branch-name> ``` tags we've created to rebase our branches. For example, let's say that ``` feature-a ``` changes (e.g., a new commit is added), and we want to update ``` feature-b ``` to point to the new HEAD of ``` feature-a ```.

## Step 1: Create a new future commit

The first thing that we'll need to do is create a new future commit for now modified ``` feature-a ``` branch. We can do this directly off of the master branch. Type in the following instructions:

```

git checkout master --detach
git merge --no-ff -m"future! feature-a" feature-a
git tag -f future/feature-a

```

This is similar to how we created future commits previously. The one difference here is that we're creating the merge commit for our feature on top of the master while in the "detached HEAD" state because we don't have a new branch that we can create and work with. By being in the detached HEAD state, any changes we make will not be implemented in master when creating our merge commit. We can then tag the new commit with the ``` future/feature-a ``` tag as we usually do.

## Step 2: Moving the dependent feature branch

This leaves us with the tag pointing to the new future commit, and we can now rebase our other branch(es) onto the commit where the tag references. In our example, our branch is ``` feature-b ```, and we want it rebased onto the new future commit.

```

git rebase --onto future/feature-a 'feature-b^{/future! feature-a}' feature-b

```

This rebase might look a bit complicated, but it's straightforward from right to left (backwards): What it does is rebase commits from ``` feature-b ``` up to the commit with the commit message "future! feature-a" in the ``` feature-b ``` branch onto the commit that the tag ``` future/feature-a ``` references.

```

before rebase:

          
(a)---('feature-b^{/future! feature-a}')---(x)---(y)---(feature-b)
         
/
--(master)
         
\
          
(a)---(b)---(future/feature-a)


after rebase:

--(master)
         
\
          
(a)---(b)---(future/feature-a)---(x)---(y)---(feature-b)

```

Basically, we want to make sure that we remove all the ``` feature-b ``` commits over to the new future commit, and we can achieve this by searching for the old future commit by its commit message.

If we have more branches that depend on ``` feature-a ```, we can repeat step 2 for each of those branches.

If we have a branch that depends on ``` feature-b ```, we can repeat steps 1 for ``` feature-b ``` and step 2 for the branch(es) that depend on ``` feature-b ```.

[Back to the top](#Git-"Future-Commit"-Workflow)

## Removing Future Commits 

When a feature's dependency is merged into master, we can use the same rebasing technique to remove the future commit for that dependency and bring our feature out of a work-in-progress state. The only difference is that we will rebase onto master rather than some future merge commit marked by some ``` future/<branch-name> ``` tag.

```

git rebase --onto master future/feature-a feature-b

```

This command rebases our ``` feature-b ``` branch onto ``` master ``` up to the ``` future/feature-a ``` tag. This is a lot like our previous rebase command to move our ``` feature-b ``` branch onto a new future commit. However, this time our new future commit is the actual merge commit.

If we have a ``` feature-c ``` that depended on ``` feature-b ```, we can follow the rebasing technique previously discussed to move the ``` feature-c ``` branch to a new future commit for ``` feature-b ```.

After all of the rebasing is complete, we can delete the ``` future/feature-a ``` tag for cleanup using the following command:

```

git tag -d future/feature-a

```

[Back to the top](#Git-"Future-Commit"-Workflow)

## Review Conventions

All pull requests for features that include one or more future commits should be "Draft" PRs on GitHub. This way, a reviewer knows not to merge after approval until it is ready for merge.

The PR should be converted to "Open" once all the future commits have been removed because the feature dependencies have been merged to master. Only after this can the requester or reviewer merge the approved PR. * It is the requester's responsibility to merge open and approved PRs *.

[Back to the top](#Git-"Future-Commit"-Workflow)

## Git Aliases

Below are two git aliases that can replace the most tricky set of git commands. Add these git aliases to your ``` ~/.gitconfig ``` file.

#### git future [<future-branch>][<feature-branch>]

```

[alias]
  future = "!f(){ \
     
futureBranch=${1:-$(git branch --show-current)}; \
     
featureBranch=$2; \
     
git checkout master --detach; \
     
git merge --no-ff -m\"future! $futureBranch\" $futureBranch && ( \
       
git tag -f future/$futureBranch; \
       
test $featureBranch && ( \
         
git checkout -b $featureBranch || \
           
git portal $futureBranch $featureBranch; \
        ) \
      ) \
    }; f"

```

This alias creates a new future commit for the given ``` <future-branch> ``` argument with a ``` future/<future-branch> ``` tag referencing the future commit. If no ``` <future-branch> ``` argument is given, it will default to the current checked out branch.

If the optional argument ``` <feature-branch> ``` is provided, it will either create a new branch at the future commit using this argument as its name if the branch doesn't exist; otherwise, it will rebase the existing branch onto the new future commit using ``` git portal ```.

#### git portal <future-branch> [<feature-branch>]

```

[alias]
  portal = "!f(){ \
   
futureBranch=$1; \
   
featureBranch=${2:-$(git branch --show-current)}; \
    test $featureBranch && ( \
     
git rev-parse \"$featureBranch^{/future! $futureBranch}\" &> /dev/null && ( \
       
git rebase --onto \"future/$futureBranch\" \"$featureBranch^{/future! $futureBranch}\" \"$featureBranch\"; \
      ) || ( \
       
git rebase \"future/$futureBranch\" \"$featureBranch\"; \
      ) \
    ) || ( \
     
echo \"Cannot omit feature branch while in detached HEAD\n\ngit portal $futureBranch <feature-branch>\" &&  \
     
exit 1; \
    ) \
  }; f"

```

This alias moves the ``` <feature-branch> ``` to the current future commit for ``` <future-branch> ```.  This works by rebasing ``` <feature-branch> ``` onto the commit where ``` future/<future-branch> ``` tag references.

This will take care of step 2 of the Rewriting History mentioned above.

If the command ``` <feature-branch> ``` is omitted, then it will use the currently checked out branch as the feature branch.

In addition, if ``` <feature-branch> ``` does not have a future commit for the ``` <future-branch> ``` in its upstream, then it will rebase all the way to the fork of the two branches. This is useful for rebasing existing branches onto some new dependency branches.

[Back to the top](#Git-"Future-Commit"-Workflow)

Git Pull Request Rules
# Pull Request Rules

* [Use "future commits" and rebasing for feature dependencies](#Use-"future-commits"-and-rebasing-for-feature-dependencies)
* [Use "fixup commits" for changes from PR feedback](#Use-"fixup-commits"-for-changes-from-PR-feedback)
 - [Example](#Example)
 - [Modifying commit messages](#Modifying-commit-messages)

## Use "future commits" and rebasing for feature dependencies
* If ``` branch-b ``` builds on ``` branch-a ``` and ``` branch-a ``` has not yet been merged into master, then create a fake merge commit for ``` branch-a ``` and build ``` branch-b ``` at that merge commit. Use "future! branch-a" as the commit message.
* When creating the PR for ``` branch-b ```, use [GitHub's draft pull-request](#https://github.blog/2019-02-14-introducing-draft-pull-requests/) feature. This will let the reviewer(s) know that the project is a work-in-progress. The draft status can be removed once ``` branch-b ``` has been rebased onto master and there are no longer future commits in the branch.
* For an in-depth guide into this workflow, see: Workflow Conventions

## Use "fixup commits" for changes from PR feedback
* A pull-requester should use "fixup commits" to resolve each requested change when a reviewer requests a change during the review of a PR. The structure of the fixup commit will start with the prefix "fixup!" followed by the commit message of the commit it is fixing.

```

git commit --fixup <commit-hash>

```

These fixup commits will simplify the process of reviewing each change in isolation and make it simpler to determine if a requested change has been adequately resolved.

* After all feedback has been resolved, the fixup commits should be squashed into the relevant commit using the command ``` git rebase -i --autosquash <commit-hash> ```. Git will automatically move all fixup commits into their correct place with the correct rebase action for you.

* Autosquash can be enabled by default using ``` git config --global rebase.autosquash true ```. After doing so, you can do ``` git rebase -i <commit-hash> ``` without having to include the ``` -- autosquash ``` argument.

* Using the ``` git commit --fixup <commit-hash> ```, you can create fixup commits. Alternatively, you can use the commit message: ``` git commit --fixup ':/Commit message' ```. By using ``` :/ ``` followed by the commit message will tell git to find the most recent commit message will tell git to find the most recent commit matching the message text that you provided. If you don't enter your commit message fully, git will try to match it. However, be cautious that you don't unintentionally match the wrong commit.

[Back to the top](#Pull-Request-Rules)

## Example

Let's say you create a new component feature, and some configuration changes are required to go along with your component.

```

git commit -m" Add an awesome component to a screen"
# ...
git commit -m "Updated some configurations for awesome component"

```

The reviewer then requests a change in your component's code during the review. You will then need to create the fixup commit.

```

git commit --fixup ':/Add an awesome component to a screen'

```

But this change also affects the configuration. So, you then have to make another fixup commit to be squashed separately.

```

git commit --fixup ':/Updated some configurations for awesome component'

```

The reviewer can now clearly see the changes made and view the outstanding issues.

Once all reviewing is complete and the PR is approved, the requester must squash the commits using rebase:

```

git rebase -i --autosquash HEAD~4

```

** In editor **:

```

pick abc111 fixup! Add an awesome component to a screen
fixup abc333 fixup! Add an awesome component to a screen
pick abc222 Updated some configurations for awesome component
fixup abc444 fixup! Updated some configurations for awesome component

```

After rebasing, the requester will force push the changes to update the PR. If there are no more commits left to rebase or no code changes left to be reviewed, the PR should be merged by the requester. The reviewer can also merge if they would like to.

[Back to the top](#Pull-Request-Rules)

## Modifying commit messages

You can also use the ``` --squash ``` argument instead of ``` --fixup ```. This will allow you to add something to the commit message for the "fixup commit" (or "squash commit"). Remember that you must leave the "squash!" line of text in your commit message for git to know where to place your commit when rebasing your commit using autosquash. For example:

```

squash! My cool feature

My cool feature with extra coolness

```

Git will mark your squash commit with the squash rebase action when rebasing. It will also allow you to edit the final commit message (your original commit message and the squash commit message will be included in your terminal editor):

```

# This is a combination of 2 commits.
# This is the 1st commit message:

My cool feature

# This is the commit message #2:

squash! My cool feature

My cool feature with extra coolness

```

You can delete all of the lines except for the last line to replace the commit message for your final commit. :hotsprings:

[Back to the top](#Pull-Request-Rules)

Utilities and recommended applications
# Recommended Applications :small_red_triangle_down:

## Motivation :shipit:
:low_brightness: Below are applications that we have experience using and can assist with configuration and troubleshooting.

It is not mandatory to use these applications. However, we cannot guarantee that everything will work or know how to troubleshoot any issues you may have. :low_brightness:

#### OS :red_circle:
* Mac OS 10.4-11.3

#### Code Editor :red_circle:
* [vscode](#https://code.visualstudio.com/) - Setting files for the required and recommended configurations are inside the "utilities/apps/vscode" folder.

#### Git Client (GUI) :red_circle:
* [SourceTree](#https://www.sourcetreeapp.com/)

:arrow_up: [Back to the top](#Recommended-Applications) :arrow_up:

Utilities and CORE Libraries :diamond_shape_with_a_dot_inside:

# CORE Libraries :trident:

* [Motivation](#Motivation) :point_left:
* [Data validation](#Data-validation) :point_left:
* [Data storage](#Data-storage) :point_left:
* [CLI/Dev Tools](#CLI/Dev-Tools) :point_left:

## Motivation :small_red_triangle_down:
:shipit: These libraries were written by CORE Multichain to address a variety of problems and are used across our repositories. Most of the time, you will be required to use these tools when working on our repos. :shipit:

## Data Validation :small_red_triangle_down:
* [cleaners](#https://www.npmjs.com/package/cleaners) - Cleans and validates untrusted data with TypeScript & Flow support  :large_blue_diamond:
* [cleaner-configs](#https://www.npmjs.com/package/cleaner-config) - A utility to easily manage strongly-types JSON  configs using cleaners for runtime type-checking. :large_blue_diamond:

## Data Storage :small_red_triangle_down:
* [disklet](#https://www.npmjs.com/package/disklet) - A tiny composable filesystem API :v:
* [memlet](#https://www.npmjs.com/package/memlet) - Memory caching library written on top of the Disklet :v:
* [baselet](#https://www.npmjs.com/package/baselet) - Simple database built on disklet :v:

## CLI/Dev Tools :small_red_triangle_down:
* [Updot](#https://www.npmjs.com/package/updot) - Copy dependencies from repos in the ../folder to current repo's node  modules. :hotsprings:


:top: [Back to the top](#CORE-Libraries) :top:
